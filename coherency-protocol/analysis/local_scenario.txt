SC_L_1: Init = root write. Action = local read

CORE    0  _    CORE_SNOOP_RESPONSE.I_FWD_M        1005

CORE    1  _    L2_RQSTS.DEMAND_DATA_RD_MISS       986
CORE    1  _    MEM_LOAD_RETIRED.L2_MISS           985
CORE    1  _    OFFCORE_REQUESTS.DEMAND_DATA_RD    986
CORE    1  _    LONGEST_LAT_CACHE.REFERENCE        1003
CORE    1  _    MEM_LOAD_L3_HIT_RETIRED.XSNP_FWD   984
CORE    1  _    L2_LINES_OUT                       1003
CORE    1  _    L2_LINES_IN                        1003

SOCKET  0  CHA  LLC_LOOKUP.READ_HIT                1144
SOCKET  0  CHA  LLC_LOOKUP.READ_SF_HIT             1074
SOCKET  0  CHA  LLC_LOOKUP.SF_E                    1055
SOCKET  0  CHA  CORE_SNP.CORE_ONE                  1052
SOCKET  0  CHA  _XSNP_RESP._CORE_RSPI_FWDM         1024
SOCKET  0  CHA  SNOOP_RSP_MISC.M_TO_I_RSP_I_FWD_M  1027

- We assume/know that the line is in M state, in root's L1/L2.

- Local reader: R1, core 1
- Root: RT, core 0

1. R1 misses in his private L1/L2
	- L2_RQSTS.DEMAND_DATA_RD_MISS
	- MEM_LOAD_RETIRED.L2_MISS

2. R1 sends the request to the associated CHA (CHx)
	- OFFCORE_REQUESTS.DEMAND_DATA_RD
	- LONGEST_LAT_CACHE.REFERENCE

3. CHx checks the LLC/SF, and finds the line in the SF in E
	- LLC_LOOKUP.READ_HIT
	- LLC_LOOKUP.READ_SF_HIT
	- LLC_LOOKUP.SF_E

4. CHx snoops RT
	- CORE_SNP.CORE_ONE
	
5. RT responds with IFwdM
	-> Will invalidate line from cache, will forward data, state was M
	- CORE_SNOOP_RESPONSE.I_FWD_M

6. CHx receives the snoop response (RspIFwdM)
	- _XSNP_RESP._CORE_RSPI_FWDM
	- SNOOP_RSP_MISC.M_TO_I_RSP_I_FWD_M

7. CHx will now give the line to R1
	- L2_LINES_OUT/IN

x. The line will also be allocated in the LLC in M state; see SC_L_2.

Other events:

- MEM_LOAD_L3_HIT_RETIRED.XSNP_FWD
	The load was satisfied through hit in L3, cross-core snoops were
	necessary, and data was forwarded along with the snoop response.

--------------------------------------------------------------

SC_L_2: Init = root write, local read. Action = 2nd local read

CORE    1  _    CORE_SNOOP_RESPONSE.S_HIT_FSE        999

CORE    2  _    L2_RQSTS.DEMAND_DATA_RD_MISS         986
CORE    2  _    MEM_LOAD_RETIRED.L2_MISS             985
CORE    2  _    OFFCORE_REQUESTS.DEMAND_DATA_RD      986
CORE    2  _    LONGEST_LAT_CACHE.REFERENCE          1003
CORE    2  _    MEM_LOAD_L3_HIT_RETIRED.XSNP_NO_FWD  984
CORE    2  _    L2_LINES_OUT                         1003
CORE    2  _    L2_LINES_IN                          1003

SOCKET  0  CHA  LLC_LOOKUP.READ_HIT                  1149
SOCKET  0  CHA  LLC_LOOKUP.M                         1044
SOCKET  0  CHA  CORE_SNP.CORE_ONE                    1050
SOCKET  0  CHA  _XSNP_RESP._CORE_RSP_HITFSE          1049

- 2nd local reader: R2, core 2
- Root: RT, core 0

1. R2 misses in his private L1/L2
	- L2_RQSTS.DEMAND_DATA_RD_MISS
	- MEM_LOAD_RETIRED.L2_MISS

2. R2 sends the request to the associated CHA (CHx)
	- OFFCORE_REQUESTS.DEMAND_DATA_RD
	- LONGEST_LAT_CACHE.REFERENCE

3. CHx checks the LLC and SF, finds the line in the LLC in M
	- LLC_LOOKUP.READ_HIT
	- LLC_LOOKUP.M

We know (from the previous scenario) that the line is cached in R1's local
cache in exclusive state. CHx knows it too. Though we don't get a correpsonding
event. Probably because this information is stored in the LLC tag slice (e.g.
CoreValid bits), rather than on the SF.

4. CHx snoops the core (R1) (to determine the state of the line)
	- CORE_SNP.CORE_ONE

5. R1 responds with SHitF/S/E
	-> Will keep line in S state, line was in F/S/E (clean)
	- CORE_SNOOP_RESPONSE.S_HIT_FSE

6. CHx recevies the snoop response
	- _XSNP_RESP._CORE_RSP_HITFSE
	-> CHx knows that the data in LLC is clean

7. CHx will now give the line to R2
	- L2_LINES_OUT/IN

Other events:

- MEM_LOAD_L3_HIT_RETIRED.XSNP_NO_FWD
	The load was satisfied through hit in L3, cross-core snoops were necessary,
	but no data needed to be forwarded (because it present was in the LLC).

-----------------------------------------------------------------

SC_L_3: Init = root write, 2x local read. Action = 3rd local read

CORE    3  _    L2_RQSTS.DEMAND_DATA_RD_MISS       986
CORE    3  _    MEM_LOAD_RETIRED.L2_MISS           985
CORE    3  _    OFFCORE_REQUESTS.DEMAND_DATA_RD    986
CORE    3  _    LONGEST_LAT_CACHE.REFERENCE        1003
CORE    3  _    MEM_LOAD_RETIRED.L3_HIT            984
CORE    3  _    MEM_LOAD_L3_HIT_RETIRED.XSNP_NONE  984
CORE    3  _    L2_LINES_OUT                       1003
CORE    3  _    L2_LINES_IN                        1003

SOCKET  0  CHA  LLC_LOOKUP.READ_HIT                1124
SOCKET  0  CHA  LLC_LOOKUP.M                       1035

- 3rd local reader: Rn, core 3
- Root: RT, core 0

1. Rn misses in his private L1/L2
	- L2_RQSTS.DEMAND_DATA_RD_MISS
	- MEM_LOAD_RETIRED.L2_MISS

2. Rn sends the request to the associated CHA (CHx)
	- OFFCORE_REQUESTS.DEMAND_DATA_RD
	- LONGEST_LAT_CACHE.REFERENCE

3. CHx hits in the LLC in M
	- LLC_LOOKUP.READ_HIT
	- LLC_LOOKUP.M

In this instance, the LLC knows (through the entry's tag), that the line is
cached in more than one private cache. Thus it can't be in eclusive (E) or
modified (M) state in any of them. Therefore, the data in the LLC is clean.

4. CHx uses the value from the LLC and gives the line to Rn
	- L2_LINES_OUT/IN

Other events:

- MEM_LOAD_L3_HIT_RETIRED.XSNP_NONE
	The load was satisifed through hit in the L3.
	No cross-core snoops were required.
